# **11SE Task 2 2025 - Typing Speed Tester**
### By Shawn

# **Sprint 1**
## **Requirements Definition**
### **Functional Requirements**
Consider the following elements when developing your functional requirements.

- **Data Retrieval:** What does the user need to be able to view in the system?

The user needs to be able to view the randomised words for the typing test and their input as they type them which will end after the chosen amount of words are typed. The system should take the data of how much time the user took to type those words in the typing test and then calculate the words per minute.

- **User Interface:** What is required for the user to interact with the system?

The user should be able to view and type out the randomised words and interact with the button to try it again. There will also be an option to change how many words the user wants in the speed test. If there is an error made while typing, the user cannot progress until the error is resolved (they type the right character). There should also be an exit button either on the user interface or just on the window to exit the application.

- **Data Display:** What information does the user need to obtain from the system? What needs to be output for the user?

The user needs to be able to view their words per minute result after finishing the typing test, the amount of words they chose, as well as the time taken to type it.

### **Non-Functional Requirements**
Consider the following elements when developing your non-functional requirements:

- **Performance:** How well does the system need to perform? 

The user needs to be able to instantly register the user's input from the keyboard to ensure better precision and accuracy when measuring the WPM/typing speed.

- **Reliability:** How reliable does the system and data need to be?

The system should be very reliable, as any errors or inaccuracy when retrieving data will result in an inaccurate result for displaying the WPM.

- **Usability and Accessibility:** How easy to navigate does the system need to be? What instructions will we need for users to access the system?

The system needs to be easy to navigate with minimalistic UI and display elements. The instructions on how to use/access the system will be in the README.md file attached with this project.

## **Determining Specifications**
### **Functional Specifications**
What does the system actually NEED to do?

- **User Requirements**
    - What does the user need to be able to do? List all specifications here.

- **Inputs & Outputs**
    - What inputs will the system need to accept and what outputs will it need to display?

- **Core Features**
    - At its core, what specifically does the program need to be able to do?

- **User Interaction**
    - How will users interact with the system (e.g. command-line, GUI?) and what information will it need to provide to help users navigate?

- **Error Handling**
    - What possible errors could you face that need to be handled by the system?

### **Non-Functional Specifications**
- **Performance**
    - How quickly should we try to get the system to perform tasks, what efficiency is required to maintain user engagement? How can we ensure our program remains efficient?

- **Useability / Accessibility**
    - How might you make your application more accessible? What could you do with the User Interface to improve usability?

- **Reliability**
    - What could perhaps not crash the whole system, but could be an issue and needs to be addressed? Data integrity? Illogical calculation? Menu navigation going to wrong places?

### **Use Case**
A use case in software development is a structured description of how a user (or system) interacts with a software application to achieve a specific goal. It defines:

- Actors: Who interacts with the system (e.g., user, external system).

- Preconditions: Conditions that must be met before the use case starts.

- Main Flow: The step-by-step process of how the interaction occurs.

- Alternative Flows (if needed): Variations or exceptions to the main flow.

- Postconditions: The expected outcome or result after the use case is completed.

## **Design**

## **Build and Test**

## **Review**

## **Launch**

# **Sprint 2**
## **Design**

## **Build and Test**

## **Review**

## **Launch**

# **Sprint 3**
## **Design**

## **Build and Test**

## **Review**

## **Launch**

# **Sprint 4**
## **Design**

## **Build and Test**

## **Review**

## **Launch**
